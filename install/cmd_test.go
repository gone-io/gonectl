package install

import (
	"github.com/stretchr/testify/assert"
	"os"
	"testing"
)

const code1 = `// Code generated by gonectl. DO NOT EDIT.
package main
import(
	"github.com/gone-io/gone/v2"
	"github.com/gone-io/goner/g"
	"github.com/gone-io/goner/apollo"
)

// load installed gone module LoadFunc
var loaders = []gone.LoadFunc{
	apollo.Load,
}

func GoneModuleLoad(loader gone.Loader) error {
	var ops []*g.LoadOp
	for _, f := range loaders {
		ops = append(ops, g.F(f))
	}
	return g.BuildOnceLoadFunc(ops...)(loader)
}
`

const code2 = `// Code generated by gonectl. DO NOT EDIT.
package main
import(
	"github.com/gone-io/gone/v2"
	"github.com/gone-io/goner/g"
	"github.com/gone-io/goner/apollo"
	"github.com/gone-io/goner/nacos"
)

// load installed gone module LoadFunc
var loaders = []gone.LoadFunc{
	apollo.Load,
	nacos.Load,
}

func GoneModuleLoad(loader gone.Loader) error {
	var ops []*g.LoadOp
	for _, f := range loaders {
		ops = append(ops, g.F(f))
	}
	return g.BuildOnceLoadFunc(ops...)(loader)
}
`

const code3 = `// Code generated by gonectl. DO NOT EDIT.
package main
import(
	"github.com/gone-io/gone/v2"
	"github.com/gone-io/goner/g"
	"github.com/gone-io/goner/apollo"
	"github.com/gone-io/goner/nacos"
)

// load installed gone module LoadFunc
var loaders = []gone.LoadFunc{
	apollo.Load,
	nacos.Load,
	nacos.RegistryLoad,
}

func GoneModuleLoad(loader gone.Loader) error {
	var ops []*g.LoadOp
	for _, f := range loaders {
		ops = append(ops, g.F(f))
	}
	return g.BuildOnceLoadFunc(ops...)(loader)
}
`

func TestInstall(t *testing.T) {
	type args struct {
		moduleName  string
		loaderNames []string
		onlyPrint   bool
	}
	tests := []struct {
		name    string
		args    args
		before  func() func()
		wantErr bool
	}{
		{
			name: "no loader file",
			before: func() func() {
				dir, _ := os.Getwd()
				_ = os.Chdir("testdata/module1")
				_ = os.Remove("module.load.go")
				return func() {
					file, err := os.ReadFile("module.load.go")
					assert.Nil(t, err)
					assert.Equalf(t, code1, string(file), "file content not match")
					_ = os.Remove("module.load.go")
					_ = os.Chdir(dir)
				}
			},
			args: args{
				moduleName:  "github.com/gone-io/goner/apollo",
				loaderNames: nil,
				onlyPrint:   false,
			},
			wantErr: false,
		},
		{
			name: "has loader file",
			before: func() func() {

				dir, _ := os.Getwd()
				_ = os.Chdir("testdata/module1")
				_ = os.WriteFile("module.load.go", []byte(code1), 0644)
				return func() {
					file, err := os.ReadFile("module.load.go")
					assert.Nil(t, err)
					assert.Equalf(t, code2, string(file), "file content not match")
					_ = os.Remove("module.load.go")
					_ = os.Chdir(dir)
				}
			},
			args: args{
				moduleName:  "github.com/gone-io/goner/nacos",
				loaderNames: []string{"Load"},
				onlyPrint:   false,
			},
			wantErr: false,
		},

		{
			name: "has loader file with ",
			before: func() func() {
				dir, _ := os.Getwd()
				_ = os.Chdir("testdata/module1")
				_ = os.WriteFile("module.load.go", []byte(code1), 0644)
				return func() {
					file, err := os.ReadFile("module.load.go")
					assert.Nil(t, err)
					assert.Equalf(t, code3, string(file), "file content not match")
					_ = os.Remove("module.load.go")
					_ = os.Chdir(dir)
				}
			},
			args: args{
				moduleName:  "github.com/gone-io/goner/nacos",
				loaderNames: []string{"Load", "RegistryLoad"},
				onlyPrint:   false,
			},
			wantErr: false,
		},
		{
			name: "only print",
			before: func() func() {
				dir, _ := os.Getwd()
				_ = os.Chdir("testdata/module1")
				_ = os.WriteFile("module.load.go", []byte(code1), 0644)
				return func() {
					file, err := os.ReadFile("module.load.go")
					assert.Nil(t, err)
					assert.Equalf(t, code1, string(file), "file content not match")
					_ = os.Remove("module.load.go")
					_ = os.Chdir(dir)
				}
			},
			args: args{
				moduleName:  "github.com/gone-io/goner/nacos",
				loaderNames: []string{"Load", "RegistryLoad"},
				onlyPrint:   true,
			},
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.before != nil {
				before := tt.before()
				defer before()
			}

			if err := Install(tt.args.moduleName, tt.args.loaderNames, tt.args.onlyPrint); (err != nil) != tt.wantErr {
				t.Errorf("Install() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}
